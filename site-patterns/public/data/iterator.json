{
  "pattern": {
    "name": {
      "ru": "Итератор",
      "en": "Iterator"
    },
    "type": "Поведенческий паттерн проектирования",
    "core_idea": "Паттерн Итератор отделяет алгоритм перебора элементов коллекции от самой коллекции, позволяя использовать один и тот же алгоритм для различных коллекций. Это упрощает работу с коллекциями и повышает их гибкость.",
    "description": {
      "main": "Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.",
      "detailed": "Коллекции — самая частая структура данных, которую вы можете встретить в программировании. Это набор объектов, собранный в одну кучу по каким-то причинам.",
      "bullets": []
    },
    "usage_scenarios": [
      "Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).",
      "Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.",
      "Когда вам хочется иметь единый интерфейс обхода различных структур данных."
    ],
    "structure": {
      "components": [
        {
          "name": "Iterator",
          "description": "Интерфейс Iterator предоставляет методы для перебора элементов коллекции.",
          "methods": [
            "hasNext(): Проверяет, есть ли еще элементы для итерации.",
            "next(): Возвращает следующий элемент коллекции.",
            "remove(): Удаляет текущий элемент, возвращенный методом next(), из коллекции (необязательный метод)."
          ]
        },
        {
          "name": "Iterable",
          "description": "Интерфейс Iterable определяет, что класс может быть итерируемым, то есть предоставляет возможность получить итератор для последовательного доступа к элементам.",
          "methods": [
            "iterator(): Возвращает объект типа Iterator, который используется для перебора элементов коллекции."
          ]
        }
      ]
    },
    "implementation": {
      "general": "В Java этот паттерн реализован через интерфейсы Iterator и Iterable. Эти интерфейсы обеспечивают стандартный способ итерации по элементам коллекций, таких как списки, множества и другие.",
      "steps": [
        "Создать интерфейс Iterator с методами hasNext(), next() и remove()",
        "Реализовать интерфейс Iterable в классе коллекции",
        "Реализовать метод iterator(), возвращающий экземпляр Iterator",
        "Использовать цикл for-each или явный вызов методов итератора для обхода коллекции"
      ]
    },
    "examples": [
      {
        "name": "Реализация паттерна Iterator на собственном ArrayList",
        "description": "Пример собственной реализации класса ArrayList, который поддерживает паттерн Итератор, используя интерфейсы Iterable и Iterator.",
        "code": "import java.util.Iterator;\n\npublic class MyArrayList<T> implements Iterable<T> {\n    private T[] elements;\n    private int size = 0;\n    private static final int DEFAULT_CAPACITY = 10;\n\n    public MyArrayList() {\n        elements = (T[]) new Object[DEFAULT_CAPACITY];\n    }\n\n    public void add(T element) {\n        if (size == elements.length) resize();\n        elements[size++] = element;\n    }\n\n    public T get(int index) {\n        if (index < 0 || index >= size)\n            throw new IndexOutOfBoundsException(\"Индекс вне допустимого диапазона: \" + index);\n        return elements[index];\n    }\n\n    public int size() {\n        return size;\n    }\n\n    private void resize() {\n        T[] newArray = (T[]) new Object[elements.length * 2];\n        System.arraycopy(elements, 0, newArray, 0, size);\n        elements = newArray;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new Iterator<>() {\n            private int currentIndex = 0;\n\n            @Override\n            public boolean hasNext() {\n                return currentIndex < size;\n            }\n\n            @Override\n            public T next() {\n                if (!hasNext()) throw new IllegalStateException(\"Больше нет элементов\");\n                return elements[currentIndex++];\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException(\"Удаление не поддерживается\");\n            }\n        };\n    }\n}"
      },
      {
        "name": "Интерфейс Iterator",
        "description": "Пример интерфейса Iterator в Java",
        "code": "public interface Iterator<E> {\n    boolean hasNext(); // Проверяет, есть ли еще элементы для итерирования\n\n    E next();          // Возвращает следующий элемент коллекции\n\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n}"
      },
      {
        "name": "Интерфейс Iterable",
        "description": "Пример интерфейса Iterable в Java",
        "code": "public interface Iterable<T> {\n    Iterator<T> iterator(); // Возвращает итератор для элементов коллекции\n}"
      }
    ],
    "analogies": [
      "Как экскурсовод в музее, который знает порядок осмотра экспонатов и может провести вас по всем залам, не раскрывая при этом как организовано хранение экспонатов в запасниках."
    ],
    "pros": [
      "Упрощает классы хранения данных.",
      "Позволяет реализовать различные способы обхода структуры данных",
      "Позволяет одновременно перемещаться по структуре данных в разные стороны."
    ],
    "cons": [
      "Дополнительные накладные расходы: Создание и использование итераторов требует дополнительной памяти и времени.",
      "Необходимость синхронизации при одновременном доступе: В многопоточных приложениях может потребоваться синхронизация доступа к коллекциям при использовании итераторов.",
      "Ограниченная функциональность: Итераторы обычно предоставляют только последовательный доступ к элементам, что может быть недостаточно для некоторых задач.",
      "Необходимость правильного использования методов hasNext() и next(): Ошибки в логике перебора могут привести к пропуску элементов или выбросу исключений."
    ],
    "conclusion": "Паттерн Итератор (Iterator) является фундаментальным поведенческим паттерном, который предоставляет стандартный способ перебора элементов коллекций без раскрытия их внутренней структуры. Он способствует снижению связанности между клиентским кодом и коллекциями, обеспечивая гибкость и расширяемость системы.\n\nОднако, при использовании паттерна Итератор важно учитывать его преимущества и недостатки, особенно в контексте производительности и синхронизации в многопоточных приложениях.",
    "sources": [
      "Design Patterns with Java: Iterator",
      "Введение в паттерны проектирования: Итератор"
    ]
  }
}