{
  "pattern": {
    "name": {
      "ru": "Компоновщик",
      "en": "Composite"
    },
    "type": "Структурный",
    "description": {
      "main": "Позволяет сгруппировать объекты в древовидную структуру и работать с ними как с единым объектом",
      "detailed": "Паттерн Компоновщик имеет смысл только тогда, когда основная модель вашей программы может быть структурирована в виде дерева. Основная идея заключается в создании единого интерфейса для работы как с простыми, так и с составными объектами."
    },
    "usage_scenarios": [
      "Необходимо представить иерархическую структуру объектов",
      "Требуется одинаковое обращение к отдельным объектам и их композициям",
      "Нужно добавлять новые виды объектов без изменения существующего кода",
      "Структура иерархии должна быть гибкой и расширяемой"
    ],
    "structure": {
      "components": [
        {
          "name": "Component",
          "description": "Общий интерфейс для всех элементов дерева",
          "methods": [
            "Integer calcCost() - вычисление стоимости",
            "Node getParent() - получение родителя",
            "void setParent(Node parent) - установка родителя"
          ]
        },
        {
          "name": "Leaf",
          "description": "Конечный элемент иерархии (лист)",
          "methods": [
            "Integer calcCost() - возвращает собственную стоимость"
          ]
        },
        {
          "name": "Composite",
          "description": "Контейнер, который может содержать другие компоненты",
          "methods": [
            "void add(Node node) - добавление элемента",
            "void remove(Node node) - удаление элемента",
            "List<Node> getChildren() - получение списка детей",
            "Integer calcCost() - вычисление суммарной стоимости"
          ]
        }
      ]
    },
    "implementation": {
  "general": "1. Создать общий интерфейс компонентов\n2. Реализовать классы листьев\n3. Реализовать классы контейнеров\n4. Добавить операции управления потомками",
      "details": {
        "hierarchy_management": "Рекурсивный обход дерева компонентов",
        "method_delegation": "Контейнеры делегируют выполнение своим дочерним компонентам",
        "parent_references": "Поддержка ссылок на родительские элементы"
      }
    },
    "examples": [
      {
        "name": "Система упаковки товаров",
        "description": "Расчет стоимости товаров в коробках и отдельных товаров",
        "code": "/**\n * Общий интерфейс элементов дерева.\n */\npublic interface Node {\n    /**\n     * Каждый элемент должен уметь посчитать свою цену.\n     * @return цена\n     */\n    Integer calcCost();\n\n    /**\n     * @return родитель\n     */\n    Node getParent();\n\n    /**\n     * @param parent родитель\n     */\n    void setParent(Node parent);\n}\n\n/**\n * Интерфейс узла контейнера.\n */\npublic interface Container extends Node {\n    /**\n     * Добавление элемента в контейнер\n     * @param node элемент\n     */\n    void add(Node node);\n\n    /**\n     * Удалить элемент из контейнера\n     * @param node элемент\n     */\n    void remove(Node node);\n\n    /**\n     * @return список детей\n     */\n    List<Node> getChildren();\n}\n\n/**\n * Коробка с товарами.\n */\npublic class Box implements Container {\n    private Node parent;\n    private List<Node> children = new LinkedList<>();\n\n    public Box(Node parent) {\n        this.parent = parent;\n    }\n\n    @Override\n    public void add(Node node) {\n        children.add(node);\n    }\n\n    @Override\n    public void remove(Node node) {\n        children.remove(node);\n    }\n\n    @Override\n    public List<Node> getChildren() {\n        return children;\n    }\n\n    @Override\n    public Integer calcCost() {\n        int res = 0;\n        for (var item : children) res += item.calcCost();\n        return res;\n    }\n\n    @Override\n    public Node getParent() {\n        return parent;\n    }\n\n    @Override\n    public void setParent(Node parent) {\n        this.parent = parent;\n    }\n}\n\n/**\n * Товар - конечный элемент.\n */\npublic class Item implements Node {\n    private Node parent;\n    private Integer cost;\n\n    public Item(Node parent, Integer cost) {\n        this.parent = parent;\n        this.cost = cost;\n    }\n\n    @Override\n    public Integer calcCost() {\n        return cost;\n    }\n\n    @Override\n    public Node getParent() {\n        return parent;\n    }\n\n    @Override\n    public void setParent(Node parent) {\n        this.parent = parent;\n    }\n}"
      },
      {
        "name": "Пример из Swing",
        "description": "Иерархия компонентов GUI в Java Swing",
        "code": "// Пример использования Composite в Swing\nJFrame frame = new JFrame();\nJPanel panel = new JPanel();\n\n// Добавляем простые компоненты (Leaf)\npanel.add(new JButton(\"Click me\"));\npanel.add(new JLabel(\"Hello\"));\n\n// Добавляем панель во фрейм (Composite)\nframe.add(panel);\n\n// Все компоненты имеют общий родительский класс - java.awt.Component"
      }
    ],
    "advantages": [
      "Простота использования: Клиенты могут взаимодействовать с отдельными объектами и их композициями одинаково",
      "Гибкость структуры: Легко добавлять новые виды компонентов",
      "Повторное использование кода: Общие операции в базовом компоненте",
      "Упрощение кода клиента: Не нужно проверять тип объекта"
    ],
    "disadvantages": [
      "Сложность реализации для небольших систем",
      "Производительность: Рекурсивные вызовы для больших иерархий",
      "Ограниченная функциональность: Некоторые операции требуют обхода иерархии"
    ],
    "comparison_table": {
      "title": "Сравнение элементов паттерна",
      "headers": ["Элемент", "Роль", "Особенности"],
      "rows": [
        ["Component", "Базовый интерфейс", "Определяет общее поведение"],
        ["Leaf", "Конечный элемент", "Реализует конкретное поведение"],
        ["Composite", "Контейнер", "Содержит другие компоненты, делегирует операции"]
      ]
    },
    "criticism": {
      "points": [
        "Может нарушать принцип разделения интерфейсов (ISP)",
        "Не всегда очевидна структура для новых разработчиков",
        "Избыточен для простых иерархий"
      ]
    },
    "pros": [
   "Простота использования: Клиенты могут взаимодействовать с отдельными объектами и их композициями одинаково, упрощая код.",
   "Гибкость структуры: Легко добавлять новые виды компонентов и композитов без изменения существующего кода.",
   "Повторное использование кода: Общие операции могут быть реализованы в базовом компоненте, уменьшая дублирование.",
   "Упрощение кода клиента: Клиенты не нуждаются в проверке типа объекта; они работают через общий интерфейс."
    ],
    "cons": [
     "Сложность реализации: Для небольших систем использование паттерна Компоновщик может быть избыточным.",
     "Производительность: Рекурсивные вызовы могут влиять на производительность при работе с большими иерархиями.",
     "Ограниченная функциональность: Некоторые специфические операции могут требовать дополнительной обработки или обхода иерархии."
    ],
    "conclusion":[ "Паттерн проектирования Компоновщик предоставляет мощный механизм для организации иерархических структур объектов, обеспечивая единообразное взаимодействие с ними. Он широко применяется в различных областях разработки, включая графические интерфейсы, файловые системы и коллекции.Понимание и правильное применение паттерна Компоновщик способствует созданию гибких, расширяемых и легко поддерживаемых систем. Однако, как и любой паттерн, его следует применять осознанно, учитывая требования и особенности конкретного проекта."
 ] }
}