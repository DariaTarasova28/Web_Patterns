{
  "pattern": {
    "name": {
      "ru": "Прототип",
      "en": "Prototype"
    },
    "type": "Порождающий паттерн проектирования",
    "description": {
      "main": "Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.",
      "detailed": "Прототип особенно полезен при создании сложных или ресурсоемких объектов. Чтобы не создавать индетичный/схожий сложный объект с нуля, мы просто копируем объект, а затем меняем нужные параметры."
    },
    "advantages": [
      "Повышение производительности",
      "Гибкость и расширяемость",
      "Изоляция процессов создания",
      "Упрощение кода"
    ],
    "implementation": {
      "general": "Основная идея паттерна Прототип заключается в том, чтобы определить виды объектов, которые могут быть клонированы, и создать копии этих объектов без привязки к их конкретным классам.",
      "variations": [
        "Интерфейс прототипов описывает операции клонирования (метод clone)",
        "Конкретный прототип реализует операцию клонирования самого себя",
        "Клиент создаёт копию объекта, обращаясь к нему через общий интерфейс прототипов"
      ],
      "details": {
        "java_implementation": "В ЯП Java паттерн прототип применяется реализацией интерфейса Cloneable классом и перегрузкой метода clone(). Отдельное внимание стоит обратить на проблему поверхностного-глубокого копирования.",
        "important_notes": [
          "Метод clone относится к классу Object, также как например hashCode()",
          "Метод clone по умолчанию наследованный от класса Object выполняет поверхностное копирование",
          "Классы, которые поддерживают копирование должны быть помечены маркерным интерфейсом Cloneable"
        ],
        "implementation_features": [
          "Операция копирования является потенциально опасной и требует обработки",
          "Метод clone() наследуется от класса Object и поэтому вроде как поддерживается всеми классами и объектами (доступен, но по умолчанию нереализован)",
          "Проверка того что объект может быть клонирован работает за счет маркерного интерфейса Cloneable",
          "Для правильного копирования сложных объектов необходимо грамотно работать с глубоким копированием"
        ]
      }
    },
    "usage_scenarios": [
      "Когда создание объекта напрямую является ресурсоёмким: Если создание объекта требует значительных затрат времени или ресурсов, клонирование существующего объекта может быть более эффективным",
      "Когда требуется создать объект, соответствующий определённому состоянию: Если требуется создать объект с определённым состоянием, который уже существует, прототип может служить шаблоном",
      "Когда системы должны быть независимыми от классов создаваемых объектов: Паттерн Прототип позволяет системе создавать объекты без знания о конкретных классах",
      "Когда необходимо динамически добавлять новые виды объектов: Паттерн позволяет легко расширять систему новыми типами объектов путем добавления новых прототипов"
    ],
    "examples": [
      {
        "name": "Класс Auto",
        "description": "Полная реализация класса Auto с методом clone() и комментариями",
        "code": "import java.util.Objects;\n\n/**\n * Класс автомобиля.\n * 10 параметров нужны для иллюстрации удобства использования\n * паттерна Прототип (метод clone и интерфейс Cloneable)\n * <p>\n * При переопределении метода clone важно чтобы соблюдалось следующее:\n * - У объектов разные ссылки prototype != clone\n * - Классы у объектов индетичны prototype.getClass() == clone.getClass()\n * - Объекты индетичны после копирования (для этого надо правильно переопределить equals())\n */\npublic class Auto implements Cloneable {\n    String owner;               //хозяин\n    String brand;               //бренд авто\n    Engine engine;              //тип двигателя\n    Gearbox gearbox;            //тип коробки передач\n    Color color;                //цвет автомобиля\n    Integer mileage;            //пробег\n    Integer seatCapacity;       //кол-во посадочных мест\n    Integer wheelCount;         //кол-во колес\n    Integer accidentsNumber;    //кол-во аварий\n    Long price;                 //стоимость\n\n    public Auto(String owner,\n                String brand,\n                Engine engine,\n                Gearbox gearbox,\n                Color color,\n                Integer mileage,\n                Integer seatCapacity,\n                Integer wheelCount,\n                Integer accidentsNumber,\n                Long price) {\n        this.owner = owner;\n        this.brand = brand;\n        this.engine = engine;\n        this.gearbox = gearbox;\n        this.color = color;\n        this.mileage = mileage;\n        this.seatCapacity = seatCapacity;\n        this.wheelCount = wheelCount;\n        this.accidentsNumber = accidentsNumber;\n        this.price = price;\n    }\n\n    /**\n     * Для проверки правильности копирования переопределим\n     * метод equals\n     * @param otherObject объект для сравнения\n     * @return true если объекты индентичны\n     */\n    @Override\n    public boolean equals(Object otherObject) {\n        if (Objects.isNull(otherObject)) return false;\n        if (this == otherObject) return true;\n        if (getClass() != otherObject.getClass()) return false;\n\n        Auto other = (Auto) otherObject;\n\n        return owner.equals(other.owner) &&\n                brand.equals(other.brand) &&\n                engine.equals(other.engine) &&\n                gearbox.equals(other.gearbox) &&\n                color.equals(other.color) &&\n                mileage.equals(other.mileage) &&\n                seatCapacity.equals(other.seatCapacity) &&\n                wheelCount.equals(other.wheelCount) &&\n                accidentsNumber.equals(other.accidentsNumber) &&\n                price.equals(other.price);\n    }\n\n    /**\n     * Метод копирования.\n     * Сначала см. Engine\n     * <p>\n     * Поскольку класс Auto в качестве поля содержит класс Engine,\n     * то \"поверхностного\" копирования недостаточно.\n     * Такая же проблема может быть при создании конструктора копирования в лоб.\n     * Обычно в Java для создания копий предпочитают всё же clone, а не конструктор копирования.\n     *\n     * @return копию автомобиля\n     */\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        Auto copy = (Auto) super.clone();           //поверхностно скопировали что можно\n        copy.engine = (Engine) this.engine.clone(); //докопировали вложенные объекты\n        return copy;\n    }\n\n    // Остальные методы (toString, hashCode, геттеры и сеттеры) остаются без изменений\n    // ...\n}"
      },
      {
        "name": "Класс Engine",
        "description": "Реализация класса Engine с методом clone() и комментариями",
        "code": "/**\n * Класс двигателя\n * Обратите внимание, что раз данный класс - record, то\n * методы toString, equals и hashCode для него по умолчанию переопределяются\n * правильно.\n * Это пригодиться при реализации данных методов в классе Auto\n *\n * @param hp     лошадиные силы\n * @param volume объекм\n */\npublic record Engine(Integer hp,\n                     Integer volume) implements Cloneable {\n    /**\n     * Метод копирования.\n     * <p>\n     * super.clone(); - выполянет поверхностное копирование.\n     * И поскольку в классе двигателя все поля являются примитивами\n     * поверхностного копирования достаточно.\n     *\n     * @return копия двигателя\n     * @throws CloneNotSupportedException копируемые объекты не поддерживают Cloneable\n     */\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}"
      },
      {
        "name": "Перечисления Color и GearBox",
        "description": "Реализация enum для цвета и коробки передач с комментариями",
        "code": "// Для перечислений паттерн Прототип не применим, \n// поскольку каждое значение перечисления имеет только единсвтенный экземпляр\n\npublic enum Color {\n    BLACK,\n    GRAY,\n    RED\n}\n\npublic enum Gearbox {\n    MANUAL,\n    AUTOMATIC\n}"
      }
    ],
    "pros": [
      "Повышение производительности: Создание копий объектов может быть быстрее, чем их создание с нуля, особенно если объект сложный",
      "Гибкость и расширяемость: Легко добавлять новые типы прототипов без изменения клиентского кода",
      "Изоляция процессов создания: Клиентский код не зависит от конкретных классов создаваемых объектов",
      "Упрощение кода: Избегание использования длинных цепочек конструкторов для создания объектов с множеством параметров"
    ],
    "cons": [
      "Сложность реализации: Необходимо правильно реализовать метод clone(), особенно для глубокого клонирования",
      "Проблемы с наследованием: Клонирование может стать сложным, если классы имеют сложную иерархию наследования",
      "Слабая совместимость с языком: В Java механизм клонирования с использованием Cloneable и метода clone() считается несколько устаревшим и неудобным по сравнению с альтернативными методами копирования",
      "Проблемы с безопасностью: Некорректное клонирование может привести к нарушению инвариантов объекта или к утечкам данных"
    ],
    "additional_info": {
      "fluent_interface": "Не поддерживается напрямую",
      "standard_library_example": "Интерфейс Cloneable и метод clone() в Java",
      "literature_references": {
        "book1": "Эрик Фримен, Элизабет Фримен - Паттерны проектирования",
        "book2": "Александр Швец - Паттерны проектирования (с оговоркой про частную реализацию)"
      },
      "notes": [
        "Конструктор копирования в Java не любят. К тому же добавление в конструктор дополнительных действий по глубокому копированию не приветсвуется, такие особенности лучше вынести в метод clone()",
        "Для правильного копирования сложных объектов необходимо соблюсти матрёшку правильного определения методов clone()"
      ]
    },
    "sources": [
      "Официальная документация Java",
      "Книга 'Паттерны проектирования' (Head First Design Patterns)",
      "Примеры реализации из учебных материалов"
    ]
  }
}