{
  "pattern": {
    "name": {
      "ru": "Прототип",
      "en": "Prototype"
    },
    "type": "Порождающий паттерн проектирования",
    "core_idea": "Прототип позволяет создавать копии объектов без привязки к их конкретным классам, делегируя процесс копирования самим объектам.",
    "description": {
      "main": "Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.",
      "detailed": "Прототип особенно полезен при создании сложных или ресурсоемких объектов. Чтобы не создавать идентичный/схожий сложный объект с нуля, мы просто копируем объект, а затем меняем нужные параметры.",
      "bullets": [
        "Объекты сами управляют процессом своего копирования",
        "Клиентский код работает с прототипами через общий интерфейс",
        "Позволяет создавать сложные объекты более эффективно"
      ]
    },
    "usage_scenarios": [
      "Когда создание объекта напрямую является ресурсоёмким",
      "Когда требуется создать объект, соответствующий определённому состоянию",
      "Когда системы должны быть независимыми от классов создаваемых объектов",
      "Когда необходимо динамически добавлять новые виды объектов"
    ],
    "structure": {
      "components": [
        {
          "name": "Интерфейс Prototype",
          "description": "Объявляет метод clone() для создания копий объектов",
          "methods": [
            "clone() - создает и возвращает копию объекта"
          ]
        },
        {
          "name": "Конкретный Prototype",
          "description": "Реализует операцию клонирования себя",
          "methods": [
            "clone() - конкретная реализация копирования объекта"
          ]
        },
        {
          "name": "Клиент",
          "description": "Создает новые объекты, запрашивая у прототипов их копии",
          "methods": []
        }
      ]
    },
    "implementation": {
      "general": "Основная идея паттерна Прототип заключается в том, чтобы определить виды объектов, которые могут быть клонированы, и создать копии этих объектов без привязки к их конкретным классам.",
      "steps": [
        "Создать интерфейс прототипа с методом clone()",
        "Реализовать этот интерфейс в конкретных классах",
        "Обеспечить правильное копирование (поверхностное/глубокое)",
        "В клиентском коде создавать объекты через клонирование прототипов"
      ],
      "details": {
        "java_implementation": "В ЯП Java паттерн прототип применяется реализацией интерфейса Cloneable классом и перегрузкой метода clone().",
        "important_notes": [
          "Метод clone относится к классу Object",
          "По умолчанию выполняется поверхностное копирование",
          "Классы должны быть помечены интерфейсом Cloneable"
        ],
        "implementation_features": [
          "Необходимо обрабатывать CloneNotSupportedException",
          "Для сложных объектов требуется глубокое копирование",
          "Метод clone() должен корректно работать с equals() и hashCode()"
        ]
      }
    },
    "examples": [
      {
        "name": "Класс Auto",
        "description": "Полная реализация класса Auto с методом clone() и комментариями",
        "code": "import java.util.Objects;\n\npublic class Auto implements Cloneable {\n    String owner;\n    String brand;\n    Engine engine;\n    // ... другие поля\n\n    @Override\n    public boolean equals(Object otherObject) {\n        // реализация equals\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        Auto copy = (Auto) super.clone();\n        copy.engine = (Engine) this.engine.clone();\n        return copy;\n    }\n}"
      },
      {
        "name": "Класс Engine",
        "description": "Реализация класса Engine с методом clone()",
        "code": "public record Engine(Integer hp, Integer volume) implements Cloneable {\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}"
      }
    ],
    "analogies": [
      "Ксерокс для документов - создает точные копии оригинала",
      "Размножение клеток в биологии - каждая новая клетка является копией исходной"
    ],
    "comparison_table": {
      "title": "Сравнение с другими порождающими паттернами",
      "headers": ["Паттерн", "Когда использовать", "Отличие от Прототипа"],
      "rows": [
        ["Фабрика", "Когда создание объекта требует сложной логики", "Создает новые объекты, а не копирует существующие"],
        ["Одиночка", "Когда нужен только один экземпляр класса", "Запрещает создание копий объекта"],
        ["Строитель", "Когда объект имеет много параметров", "Постепенно конструирует объект, а не копирует"]
      ]
    },
    "pros": [
      "Повышение производительности",
      "Гибкость и расширяемость",
      "Изоляция процессов создания",
      "Упрощение кода"
    ],
    "cons": [
      "Сложность реализации глубокого копирования",
      "Проблемы с наследованием",
      "Устаревший механизм в Java",
      "Потенциальные проблемы с безопасностью"
    ],
    "conclusion": "Паттерн Прототип является мощным инструментом для эффективного создания объектов, особенно когда процесс создания ресурсоемкий или требует сложной инициализации. Несмотря на некоторые ограничения в реализации в Java, он остается полезным решением для задач, где требуется создание множества схожих объектов. Важно правильно реализовывать механизм копирования, особенно для сложных объектов с вложенными структурами, чтобы избежать проблем с поверхностным копированием."
  }
}